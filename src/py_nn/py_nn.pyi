# type: ignore
import sys
from typing import Literal, List, Any, Optional, Tuple, Dict
import numpy as np
import enum
import numpy

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:Tensor.hpp>    ####################

class Tensor:
    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, dims: List[int]) -> None:
        pass

    @overload
    def __init__(self, dims: List[int], data: std.vector<Value>) -> None:
        pass

    @overload
    def __call__(self, indices: List[int]) -> Value:
        pass

    @overload
    def __call__(self, indices: List[int]) -> Value:
        pass

    def __getitem__(self, index: int) -> Tensor:
        pass

    def slice(self, start: int, end: int, axis: int = 0) -> Tensor:
        pass

    def copy(self) -> Tensor:
        pass

    def fill(self, value: float) -> None:
        pass

    @overload
    def mat(self) -> std.vector<Value>:
        pass
    @overload
    def mat(self) -> std.vector<Value>:
        pass

    def rank(self) -> int:
        pass

    def dim(self) -> List[int]:
        pass

    def size(self) -> int:
        pass

    def reshape(self, new_dims: List[int]) -> None:
        pass

    def flatten(self) -> None:
        pass

    def display(self) -> None:
        pass

    def set_value_like(self, tensor: Tensor) -> None:
        pass

    def assign(self, index: int, tensor: Tensor) -> None:
        pass

    def get_values(self) -> List[float]:
        pass


    # FOR ITERATOR

    @overload
    def begin(self) -> Any:
        """
        (C++ auto return type)
        """
        pass
    @overload
    def end(self) -> Any:
        """
        (C++ auto return type)
        """
        pass
    @overload
    def begin(self) -> Any:
        """
        (C++ auto return type)
        """
        pass
    @overload
    def end(self) -> Any:
        """
        (C++ auto return type)
        """
        pass


    # Public static factory methods
    @staticmethod
    def ones(dims: List[int]) -> Tensor:
        pass
    @staticmethod
    def zeros(dims: List[int]) -> Tensor:
        pass
    @staticmethod
    def random(dims: List[int], min: float = 0.0, max: float = 1.0) -> Tensor:
        pass
    @staticmethod
    def randn(dims: List[int], mean: float = 0.0, stddev: float = 1.0) -> Tensor:
        pass
####################    </generated_from:Tensor.hpp>    ####################


####################    <generated_from:Value.hpp>    ####################


class Value:

    def __init__(self, data: float) -> None:
        """ Constructor"""
        pass

    @staticmethod
    def create(data: float) -> Value:
        pass

    # Getter for data and gradient
    def get_data(self) -> float:
        pass
    def get_grad(self) -> float:
        pass
    def get_children(self) -> std.unordered_set<Value>:
        pass
    def update_data(self, step_size: float) -> None:
        pass

    # Setter for gradient
    def accumulate_grad(self, grad: float) -> None:
        pass
    def set_gradient(self, grad: float) -> None:
        pass

    # Setter for value
    def set_value(self, val: float) -> None:
        pass
    def set_type(self, type: NodeTypes) -> None:
        pass
    def get_type(self) -> NodeTypes:
        pass

    # Set the backward function
    def add_backward(self, func: Callable[[], None]) -> None:
        pass
    def add_forward(self, func: Callable[[], None]) -> None:
        pass

    def add_child(self, child: Value) -> None:
        """ Add a child"""
        pass

    def to_string(self) -> str:
        """ String representation for debugging"""
        pass

    # Apply a binary operator and create a new Value object
    def apply_operator(
        self,
        other: Value,
        op_func: Callable[[float, float], float]
        ) -> Value:
        pass
    def add(self, other: Value) -> Value:
        pass
    def sub(self, other: Value) -> Value:
        pass
    def times(self, other: Value) -> Value:
        pass
    def div(self, other: Value) -> Value:
        pass

    # Backward pass initialization
    def backward(self) -> None:
        pass
    def forward(self) -> None:
        pass
    def zero_grad(self) -> None:
        pass
    def deref_graph(self) -> None:
        pass
####################    </generated_from:Value.hpp>    ####################


####################    <generated_from:NodesTypes.hpp>    ####################

class NodeTypes(enum.Enum):
    """ A Parameter is a special type of Value that can be updated."""
    any = enum.auto()    # (= 0)
    weight = enum.auto() # (= 1)
    bias = enum.auto()   # (= 2)
    output = enum.auto() # (= 3)####################    </generated_from:NodesTypes.hpp>    ####################

# </litgen_stub> // Autogenerated code end!