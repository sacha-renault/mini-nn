#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include "/home/wsl/Projects_code/my-nn/src/mini-nn/Values/Value.hpp"
#include "/home/wsl/Projects_code/my-nn/src/mini-nn/Values/NodesTypes.hpp"
#include "/home/wsl/Projects_code/my-nn/src/mini-nn/Tensor/Tensor.hpp"


namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


// You can add any code here


PYBIND11_MODULE(py_nn, m)       //  rename this function name!!!
{
    // You can add any code here


    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:Tensor.hpp>    ////////////////////
    auto pyClassTensor =
        py::class_<Tensor>
            (m, "Tensor", "")
        .def(py::init<>())
        .def(py::init<const std::vector<int> &>(),
            py::arg("dims"))
        .def(py::init<const std::vector<int> &, std::vector<std::shared_ptr<Value>>>(),
            py::arg("dims"), py::arg("data"))
        .def("__call__",
            py::overload_cast<const std::vector<int> &>(&Tensor::operator()), py::arg("indices"))
        .def("__getitem__",
            &Tensor::operator[], py::arg("index"))
        .def("slice",
            &Tensor::slice, py::arg("start"), py::arg("end"), py::arg("axis") = 0)
        .def("copy",
            &Tensor::copy)
        .def("fill",
            &Tensor::fill, py::arg("value"))
        .def("mat",
            [](Tensor & self) { return self.mat(); })
        .def("rank",
            &Tensor::rank)
        .def("dim",
            &Tensor::dim)
        .def("size",
            &Tensor::size)
        .def("reshape",
            &Tensor::reshape, py::arg("new_dims"))
        .def("flatten",
            &Tensor::flatten)
        .def("display",
            &Tensor::display)
        .def("set_value_like",
            &Tensor::setValueLike, py::arg("tensor"))
        .def("assign",
            &Tensor::assign, py::arg("index"), py::arg("tensor"))
        .def("get_values",
            &Tensor::getValues)
        .def_static("ones",
            &Tensor::ones, py::arg("dims"))
        .def_static("zeros",
            &Tensor::zeros, py::arg("dims"))
        .def_static("random",
            &Tensor::random, py::arg("dims"), py::arg("min") = 0.0f, py::arg("max") = 1.0f)
        .def_static("randn",
            &Tensor::randn, py::arg("dims"), py::arg("mean") = 0.0f, py::arg("stddev") = 1.0f)
        ;
    ////////////////////    </generated_from:Tensor.hpp>    ////////////////////


    ////////////////////    <generated_from:Value.hpp>    ////////////////////
    auto pyClassValue =
        py::class_<Value, std::shared_ptr<Value>>
            (m, "Value", "")
        .def(py::init<float>(),
            py::arg("data"),
            "Constructor")
        .def_static("create",
            &Value::create, py::arg("data"))
        .def("get_data",
            &Value::getData)
        .def("get_grad",
            &Value::getGrad)
        .def("get_children",
            &Value::getChildren)
        .def("update_data",
            &Value::updateData, py::arg("step_size"))
        .def("accumulate_grad",
            &Value::accumulateGrad, py::arg("grad"))
        .def("set_gradient",
            &Value::setGradient, py::arg("grad"))
        .def("set_value",
            &Value::setValue, py::arg("val"))
        .def("set_type",
            &Value::setType, py::arg("type"))
        .def("get_type",
            &Value::getType)
        .def("add_backward",
            &Value::addBackward, py::arg("func"))
        .def("add_forward",
            &Value::addForward, py::arg("func"))
        .def("add_child",
            &Value::addChild,
            py::arg("child"),
            "Add a child")
        .def("to_string",
            &Value::toString, "String representation for debugging")
        .def("apply_operator",
            &Value::applyOperator, py::arg("other"), py::arg("op_func"))
        .def("add",
            &Value::add, py::arg("other"))
        .def("sub",
            &Value::sub, py::arg("other"))
        .def("times",
            &Value::times, py::arg("other"))
        .def("div",
            &Value::div, py::arg("other"))
        .def("backward",
            &Value::backward)
        .def("forward",
            &Value::forward)
        .def("zero_grad",
            &Value::zeroGrad)
        .def("deref_graph",
            &Value::derefGraph)
        ;
    ////////////////////    </generated_from:Value.hpp>    ////////////////////


    ////////////////////    <generated_from:NodesTypes.hpp>    ////////////////////
    py::enum_<NodeTypes>(m, "NodeTypes", py::arithmetic(), "A Parameter is a special type of Value that can be updated.")
        .value("any", ANY, "")
        .value("weight", WEIGHT, "")
        .value("bias", BIAS, "")
        .value("output", OUTPUT, "");
    ////////////////////    </generated_from:NodesTypes.hpp>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}